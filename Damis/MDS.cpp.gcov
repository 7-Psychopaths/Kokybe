        -:    0:Source:MDS.cpp
        -:    0:Graph:build/Debug/GNU-Linux-x86/MDS.gcno
        -:    0:Data:build/Debug/GNU-Linux-x86/MDS.gcda
        -:    0:Runs:3
        -:    0:Programs:1
        -:    1:///////////////////////////////////////////////////////////
        -:    2://  MDS.cpp
        -:    3://  Implementation of the Class MDS
        -:    4://  Created on:      07-Lie-2013 20:07:30
        -:    5://  Original author: Povilas
        -:    6:///////////////////////////////////////////////////////////
        -:    7:
        -:    8:#include "MDS.h"
        -:    9:#include "arff.h"
        -:   10:#include "string"
        -:   11:#include "DistanceMetrics.h"
        -:   12:#include <cstdlib>
        -:   13:#include "DataObject.h"
        -:   14:#include "PCA.h"
        -:   15:#include <vector>
        -:   16:#include <cmath>
        -:   17:
    #####:   18:MDS::MDS(){
        -:   19:
    #####:   20:}
        -:   21:
        3:   22:MDS::~MDS(){
        -:   23:
        3:   24:}
        -:   25:
        -:   26:/**
        -:   27: * Constructor for MDS type object
        -:   28: */
        3:   29:MDS::MDS(double eps, int maxIter, int dimension){
        3:   30:    epsilon = eps;
        3:   31:    maxIteration = maxIter;
        3:   32:    d = dimension;
        3:   33:    int iter = 0;
        3:   34:    X = ObjectMatrix("./tests/cpu.arff");
        3:   35:    X.loadDataMatrix();
        3:   36:    n = X.getObjectCount();
        -:   37:    //Y = ObjectMatrix(X.getObjectCount());
        3:   38:    ObjectMatrix Y_new(X.getObjectCount());
        3:   39:    double sum = 0.0;
        3:   40:    double old_stress = 0.0;
        3:   41:    double new_stress = 0.0;
        3:   42:    std::vector<double> dObjVec;
        -:   43:    //for (int i = 0; i < n; i++)
        -:   44:    //{
        -:   45:    //    for (int j = 0; j < d; j++)
        -:   46:    //        dObjVec.push_back(0.1);
        -:   47:    //    Y.addObject(DataObject(dObjVec));
        -:   48:    //    dObjVec.clear();
        -:   49:    //}
        3:   50:    Y = getProjection();
        6:   51:    do
        -:   52:    {       
        6:   53:        ObjectMatrix GMatrix = MDS::getGutman();
     1260:   54:        for (int i = 0; i < n; i++)
        -:   55:        {
     3762:   56:            for (int j = 0; j < d; j++)
        -:   57:            {
     2508:   58:                sum = 0.0;
   526680:   59:                for (int k = 0; k < n; k++)
   524172:   60:                    sum += sum + GMatrix.getObjectAt(i).getItems().at(k) * Y.getObjectAt(k).getItems().at(j);
     2508:   61:                dObjVec.push_back(sum / n);
        -:   62:            }
     1254:   63:            Y_new.addObject(DataObject(dObjVec));
     1254:   64:            dObjVec.clear();
        -:   65:        }
        6:   66:        old_stress = MDS::getStress();
        6:   67:        Y = Y_new;
        6:   68:        iter++;
        6:   69:        new_stress = MDS::getStress();
    #####:   70:    } while (iter < maxIter && std::abs(old_stress - new_stress) > epsilon);
    #####:   71:}
        -:   72:
        -:   73:/**
        -:   74: * Gets eps value
        -:   75: */
    #####:   76:double MDS::getEpsilon(){
        -:   77:
    #####:   78:	return epsilon;
        -:   79:}
        -:   80:
        6:   81:ObjectMatrix MDS::getGutman(){
        6:   82:    double GMatrix[n][n];   
        6:   83:    ObjectMatrix GT_B(X.getObjectCount());  
        -:   84:    double distXij;
        -:   85:    double distYij;
        -:   86:    
        6:   87:    std::vector<double> GT_B_Row;
        -:   88:    
     1260:   89:    for (int i = 0; i < n; i++)
        -:   90:    {
   263340:   91:        for (int j = 0; j < n; j++)
        -:   92:        {
   262086:   93:            distYij = DistanceMetrics::getDistance(Y.getObjectAt(i), Y.getObjectAt(j), Euclidean);
   522918:   94:            if (i != j &&  distYij != 0)
        -:   95:            {
   260832:   96:                distXij = DistanceMetrics::getDistance(X.getObjectAt(i), X.getObjectAt(j), Euclidean);
   260832:   97:                GMatrix[i][j] = -1 * distXij/distYij;
        -:   98:            }
     1254:   99:            else if (i != j && distYij == 0)
    #####:  100:                GMatrix[i][j] = 0;
   262086:  101:            if (i == j)
        -:  102:            {
     1254:  103:                GMatrix[i][i] = 0;
   263340:  104:                for (int k = 0; k < n; k++)
   262086:  105:                    if (i < k)
   130416:  106:                        GMatrix[i][i] += GMatrix[i][i] + GMatrix[i][k];
        -:  107:            }
        -:  108:                
        -:  109:        }
        -:  110:    }
     1260:  111:    for (int i = 0; i < n; i++)
        -:  112:    {
   263340:  113:        for (int j = 0; j < n; j++)
   262086:  114:            GT_B_Row.push_back(GMatrix[i][j]);
     1254:  115:        GT_B.addObject(DataObject(GT_B_Row));
     1254:  116:        GT_B_Row.clear();
        -:  117:    }
        -:  118:    
        -:  119:    
    #####:  120:    return  GT_B;
        -:  121:}
        -:  122:
        -:  123:/**
        -:  124: * Gets max iteration
        -:  125: */
    #####:  126:int MDS::getMaxIteration(){
    #####:  127:    return maxIteration;
        -:  128:}
        -:  129:
        -:  130:/**
        -:  131: * Computes MDS stress function
        -:  132: */
       12:  133:double MDS::getStress(){
       12:  134:    double stress = 0.0;
       12:  135:    int n = X.getObjectCount();
       12:  136:    double distX = 0.0;
       12:  137:    double distY = 0.0;
        -:  138:    
     2508:  139:    for (int i = 0; i < n - 1; i++)
        -:  140:    {
   263328:  141:        for (int j = i + 1; j < n; j++)
        -:  142:        {
   260832:  143:            distX = DistanceMetrics::getDistance(X.getObjectAt(i), X.getObjectAt(j), Euclidean);
   260832:  144:            distY = DistanceMetrics::getDistance(Y.getObjectAt(i), Y.getObjectAt(j), Euclidean);
   260832:  145:            stress += getWeight(i, j) * std::pow(distX - distY, 2);
        -:  146:        }
        -:  147:    }
        -:  148:    
       12:  149:    return stress;
        -:  150:}
        -:  151:
   260832:  152:double MDS::getWeight(int i, int j)
        -:  153:{
   260832:  154:    double weight = 0.0;
        -:  155:    
 36516480:  156:    for (int j = i + 1; j < X.getObjectCount(); j++)
 36255648:  157:        weight += std::pow(DistanceMetrics::getDistance(X.getObjectAt(i), X.getObjectAt(j), Euclidean), 2);
   260832:  158:    return 1 / weight;
        -:  159:}
        -:  160:
        -:  161:/**
        -:  162: * Sets epsilon
        -:  163: */
    #####:  164:void MDS::setEpsilon(double eps){
    #####:  165:    epsilon = eps;
    #####:  166:}
        -:  167:
        -:  168:
    #####:  169:void MDS::setMaxIteration(int maxIter){
    #####:  170:    maxIteration = maxIter;
    #####:  171:}
        -:  172:
        3:  173:ObjectMatrix MDS::getProjection()
        -:  174:{
        3:  175:    PCA pca(X, d);
        3:  176:    return pca.getY();
        -:  177:}